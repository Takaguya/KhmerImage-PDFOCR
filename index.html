<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OCR File Processor</title>
    <!-- Styles -->
    <link rel="stylesheet" href="styles.css">
    <!-- Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script> <!-- TensorFlow.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script> <!-- PDF.js -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js"></script> <!-- Tesseract.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/0.4.1/html2canvas.min.js"></script> <!-- html2canvas -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.8.0/jszip.min.js"></script> <!-- JSZip -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/docxtemplater/3.19.0/docxtemplater.min.js"></script> <!-- docxtemplater -->
</head>
<body>
    <header class="main-header">
        <div class="top-section">
            <div class="logo">
                <img src="images/rupp_logo.png" alt="University Logo">
            </div>
            <div class="title">
                <h1>សាកលវិទ្យាល័យភូមិន្ទភ្នំពេញ</h1>
                <h2>ROYAL UNIVERSITY OF PHNOM PENH</h2>
            </div>
        </div>
        <div class="red-bar">
            <p>Faculty of Engineering</p>
            <p>Department of IT Engineering</p>
        </div>
    </header>

    <main>
        <div class="form-container">
            <h2 class="form-title">Upload Your File for OCR Processing</h2>
            <form id="upload-form">
                <label for="file" class="file-label">Choose a file:</label>
                <input 
                    type="file" 
                    id="file" 
                    name="file" 
                    accept="image/*, .pdf" 
                    required
                    aria-label="Choose a file to upload"
                >
                <p id="file-name" style="margin-top: 10px; font-style: italic; color: gray;">No file selected</p>
                <button type="button" id="process-button">Upload and Process</button>
            </form>
        </div>

        <div id="loading-spinner" style="display: none;">
            <p>Processing... Please wait.</p>
            <img src="images/spinner.gif" alt="Loading spinner" class="spinner">
        </div>

        <!-- Result Container for OCR and Font Detection -->
        <div id="result-container" class="result-container" style="display: none;">
            <div class="font-detection-result">
                <h3 id="font-detected"></h3>
                <p id="confidence"></p>
            </div>
            <div class="ocr-result">
                <h3>OCR Result:</h3>
                <div id="ocr-text" class="doc-preview"></div>
            </div>
        </div>

        <button id="download-docx" style="display:none;">Download DOCX</button>
    </main>

    <script>
        // Show file name after selection
        document.getElementById('file').addEventListener('change', function() {
            const fileName = this.files[0]?.name || 'No file selected';
            document.getElementById('file-name').innerText = fileName;
        });

        // Handle file upload and processing
        document.getElementById('process-button').addEventListener('click', async function() {
            const fileInput = document.getElementById('file');
            const file = fileInput.files[0];
            const outputArea = document.getElementById('font-detected');
            const confidenceArea = document.getElementById('confidence');
            const ocrTextArea = document.getElementById('ocr-text');
            const loadingSpinner = document.getElementById('loading-spinner');
            const downloadButton = document.getElementById('download-docx');
            const resultContainer = document.getElementById('result-container');
            const fileExt = file.name.split('.').pop().toLowerCase();

            if (!file) {
                alert('Please select a file');
                return;
            }

            // Show loading spinner
            loadingSpinner.style.display = 'block';
            resultContainer.style.display = 'none';  // Hide result container initially

            try {
                let ocrText = '';
                let font = '';
                let confidence = '';
                let fontClass = '';

                if (fileExt === 'pdf') {
                    // Process PDF
                    const pdfText = await processPDF(file);
                    ocrText = pdfText.text;
                    font = pdfText.font;
                    confidence = pdfText.confidence;
                    fontClass = pdfText.fontClass;
                } else if (['jpg', 'jpeg', 'png', 'bmp', 'tiff'].includes(fileExt)) {
                    // Process Image
                    const img = await loadImage(file);
                    const { font: detectedFont, confidence: detectedConfidence, fontClass: detectedFontClass } = await detectFont(img);
                    ocrText = await runOCR(img);
                    font = detectedFont;
                    confidence = detectedConfidence;
                    fontClass = detectedFontClass;
                } else {
                    alert("Unsupported file type.");
                    return;
                }

                // Display the result container with OCR and font detection details
                resultContainer.style.display = 'block';
                outputArea.innerHTML = `Font Detected: ${font}`;
                confidenceArea.innerHTML = `Confidence: ${confidence}`;
                ocrTextArea.innerHTML = `<pre>${ocrText}</pre>`;

                // Show the download button after processing
                downloadButton.style.display = 'inline-block';

                // Create the DOCX file with OCR result
                downloadButton.addEventListener('click', () => {
                    generateDocx(ocrText);
                });
            } catch (error) {
                outputArea.innerHTML = `<p>Error: ${error.message}</p>`;
            } finally {
                loadingSpinner.style.display = 'none';  // Hide loading spinner
            }
        });

        // Load image from file input
        function loadImage(file) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = URL.createObjectURL(file);
            });
        }

        // Run OCR on an image using Tesseract.js
        function runOCR(image) {
            return new Promise((resolve, reject) => {
                Tesseract.recognize(
                    image,
                    'khm+eng',
                    {
                        logger: (m) => console.log(m),
                    }
                ).then(({ data: { text } }) => {
                    resolve(text);
                }).catch(reject);
            });
        }

        // Detect font using the pre-trained TensorFlow.js model
        async function detectFont(image) {
            const model = await tf.loadLayersModel('./models/model.json');
            const preprocessedImage = preprocessImage(image);
            const predictions = await model.predict(preprocessedImage).data();
            const fontClassIndex = predictions.indexOf(Math.max(...predictions));
            const fontClasses = ["Khmer OS", "Khmer OS Battambong", "Khmer OS Siemreap"];
            const predictedFont = fontClasses[fontClassIndex];

            const fontClassMap = {
                "Khmer OS": "font-khmer-os",
                "Khmer OS Battambong": "font-khmer-os-battambong",
                "Khmer OS Siemreap": "font-khmer-os-siemreap"
            };

            return {
                font: predictedFont,
                confidence: predictions[fontClassIndex],
                fontClass: fontClassMap[predictedFont]  // Return the corresponding CSS class
            };
        }

        // Preprocess image for font classification
        function preprocessImage(image, targetSize = [256, 256]) {
            return tf.tidy(() => {
                const tensor = tf.browser.fromPixels(image)
                    .resizeBilinear(targetSize)
                    .div(tf.scalar(255))
                    .expandDims(0);  // Add batch dimension
                return tensor;
            });
        }

        // Process PDF and extract images
        async function processPDF(file) {
            const pdf = await pdfjsLib.getDocument(URL.createObjectURL(file)).promise;
            const textData = [];
            let font = null;
            let confidence = null;
            let fontClass = null;

            for (let pageNumber = 1; pageNumber <= pdf.numPages; pageNumber++) {
                const page = await pdf.getPage(pageNumber);
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                const viewport = page.getViewport({ scale: 1 });
                canvas.height = viewport.height;
                canvas.width = viewport.width;
                await page.render({ canvasContext: context, viewport }).promise;

                const image = canvas.toDataURL();  // Get image as data URL
                const img = new Image();
                img.src = image;

                img.onload = async () => {
                    const { font: pageFont, confidence: pageConfidence, fontClass: pageFontClass } = await detectFont(img);
                    if (!font || pageConfidence > confidence) {
                        font = pageFont;
                        confidence = pageConfidence;
                        fontClass = pageFontClass;
                    }
                };

                const ocrText = await runOCR(img);
                textData.push(ocrText);
            }

            return { text: textData.join('\n\n'), font, confidence, fontClass };
        }

        // Function to generate and download DOCX file
        function generateDocx(ocrText) {
            const zip = new JSZip();
            const doc = new docxtemplater();
            const content = `
                <w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
                    <w:body>
                        <w:p>
                            <w:r>
                                <w:t>${ocrText}</w:t>
                            </w:r>
                        </w:p>
                    </w:body>
                </w:document>
            `;
            zip.file("word/document.xml", content);
            zip.generateAsync({ type: "blob" }).then(function(content) {
                const fileName = "OCR_Result.docx";
                saveAs(content, fileName);
            });
        }
    </script>
</body>
</html>
