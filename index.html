<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OCR File Processor</title>
    <!-- Styles -->
    <link rel="stylesheet" href="styles.css">
    <!-- Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/onnxjs@latest"></script> <!-- ONNX.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script> <!-- PDF.js -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js"></script> <!-- Tesseract.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.8.0/jszip.min.js"></script> <!-- JSZip -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script> <!-- FileSaver.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script> <!-- TensorFlow.js -->
</head>
<body>
    <header class="main-header">
        <div class="top-section">
            <div class="logo">
                <img src="images/rupp_logo.png" alt="University Logo">
            </div>
            <div class="title">
                <h1>សាកលវិទ្យាល័យភូមិន្ទភ្នំពេញ</h1>
                <h2>ROYAL UNIVERSITY OF PHNOM PENH</h2>
            </div>
        </div>
        <div class="red-bar">
            <p>Faculty of Engineering</p>
            <p>Department of IT Engineering</p>
        </div>
    </header>

    <main>
        <div class="form-container">
            <h2 class="form-title">Upload Your File for OCR Processing</h2>
            <form id="upload-form">
                <label for="file" class="file-label">Choose a file:</label>
                <input 
                    type="file" 
                    id="file" 
                    name="file" 
                    accept="image/*, .pdf" 
                    required
                    aria-label="Choose a file to upload"
                >
                <p id="file-name" style="margin-top: 10px; font-style: italic; color: gray;">No file selected</p>
                <button type="button" id="process-button">Upload and Process</button>
            </form>
        </div>

        <div id="loading-spinner" style="display: none;">
            <p>Processing... Please wait.</p>
            <img src="images/spinner.gif" alt="Loading spinner" class="spinner">
        </div>

        <div id="result-container" class="result-container" style="display: none;">
            <div class="font-detection-result">
                <h3 id="font-detected"></h3>
                <p id="confidence"></p>
            </div>
            <div class="ocr-result">
                <h3>OCR Result:</h3>
                <div id="ocr-text" class="doc-preview"></div>
            </div>
            <button id="download-docx" style="display:none;">Download DOCX</button>
        </div>
    </main>

    <script>
        const class_labels = {
            "Khmer OS": 0,
            "Khmer OS Battambong": 1,
            "Khmer OS Siemreap": 2,
            // Add more classes as needed
        };
    
        // Load ONNX model
        const onnxModelPath = 'model.onnx';
        const session = new onnx.InferenceSession();
        await session.loadModel(onnxModelPath);
    
        // File selection handler
        document.getElementById('file').addEventListener('change', function() {
            const fileName = this.files[0]?.name || 'No file selected';
            document.getElementById('file-name').innerText = fileName;
        });
    
        // Process button click handler
        document.getElementById('process-button').addEventListener('click', async function () {
            const fileInput = document.getElementById('file');
            const file = fileInput.files[0];
            const outputArea = document.getElementById('font-detected');
            const confidenceArea = document.getElementById('confidence');
            const ocrTextArea = document.getElementById('ocr-text');
            const loadingSpinner = document.getElementById('loading-spinner');
            const downloadButton = document.getElementById('download-docx');
            const resultContainer = document.getElementById('result-container');
            const fileExt = file.name.split('.').pop().toLowerCase();
    
            if (!file) {
                alert('Please select a file');
                return;
            }
    
            loadingSpinner.style.display = 'block';
            resultContainer.style.display = 'none';
    
            try {
                let ocrText = '';
                let font = 'Unknown Font'; // Default value
                let confidence = 'N/A'; // Default value
                let fontClass = '';
    
                if (fileExt === 'pdf') {
                    const pdfText = await processPDF(file);
                    ocrText = pdfText.text;
                } else if (['jpg', 'jpeg', 'png', 'bmp', 'tiff'].includes(fileExt)) {
                    const img = await loadImage(file);
                    const fontDetection = await cropAndPredict(img);
                    ocrText = await runOCR(img);
                    font = fontDetection.font || 'Unknown Font';
                    confidence = fontDetection.confidence?.toFixed(2) || 'N/A';
                    fontClass = fontDetection.fontClass || '';
                } else {
                    alert("Unsupported file type.");
                    return;
                }
    
                resultContainer.style.display = 'block';
                outputArea.innerHTML = `Font Detected: <span class="${fontClass}">${font}</span>`;
                confidenceArea.innerHTML = `Confidence: ${confidence}`;
                ocrTextArea.innerHTML = `<pre>${ocrText}</pre>`;
                downloadButton.style.display = 'inline-block';
    
                downloadButton.addEventListener('click', () => {
                    generateDocx(ocrText, font, confidence);
                });
            } catch (error) {
                outputArea.innerHTML = `<p>Error: ${error.message}</p>`;
            } finally {
                loadingSpinner.style.display = 'none';
            }
        });
    
        // Preprocess image (updated based on your code)
        function preprocessImage(image, targetSize = [256, 256]) {
            // Convert to grayscale as the model expects a single channel
            const grayImage = image.bgrToGray();
    
            // Resize to target size
            const resizedImage = grayImage.resize(targetSize[0], targetSize[1]);
    
            // Normalize the image to [0, 1]
            const normalizedImage = resizedImage.div(255.0);
    
            // Add the channel dimension (1 for grayscale)
            return normalizedImage.reshape([1, targetSize[0], targetSize[1], 1]);  // Shape is (1, height, width, 1)
        }
    
        // Detect words and crop
        async function detectWordsAndCrop(imagePath) {
            const image = await cv.imreadAsync(imagePath);
    
            // Convert the image to grayscale for OCR
            const gray = image.bgrToGray();
    
            const config = {
                lang: 'eng+km',  // Specify languages (English + Khmer)
                psm: 6, // Page segmentation mode (uniform block of text)
            };
    
            const { data: { text, conf, left, top, width, height } } = await tesseract.recognize(image, config);
    
            const wordBoxes = [];
    
            for (let i = 0; i < text.length; i++) {
                if (parseInt(conf[i]) > 0) {
                    const word = text[i].trim();
                    if (word !== "") {
                        wordBoxes.push({
                            word,
                            x: left[i],
                            y: top[i],
                            w: width[i],
                            h: height[i],
                            conf: parseInt(conf[i]),
                        });
                    }
                }
            }
    
            return { wordBoxes, image };
        }
    
        // Crop and predict font (updated with the correct preprocess and model prediction)
        async function cropAndPredict(imagePath, numWords = 3) {
            const { wordBoxes, image } = await detectWordsAndCrop(imagePath);
    
            if (!wordBoxes.length) {
                console.log("No text detected.");
                return;
            }
    
            // Limit to the first `numWords` detected words
            const limitedWordBoxes = wordBoxes.slice(0, numWords);
            const fontResults = [];
    
            // Crop each word and predict the font
            for (const { word, x, y, w, h } of limitedWordBoxes) {
                // Crop the region containing the word
                const croppedImage = image.getRegion(new cv.Rect(x, y, w, h));
    
                // Preprocess the cropped image for prediction
                const croppedImageRgb = preprocessImage(croppedImage);
    
                // Expand the batch dimension and convert to tensor
                const inputTensor = new onnx.Tensor(croppedImageRgb.dataSync(), 'float32', [1, 1, 256, 256]);  // Shape (1, 1, 256, 256)
    
                // Run inference
                const outputs = await session.run([inputTensor]);
                const predictions = outputs[0].data;
    
                const predictedClass = predictions.indexOf(Math.max(...predictions));
                const confidence = Math.max(...predictions);
    
                // Map predicted class to font name
                const fontNames = Object.keys(class_labels);
                fontResults.push({
                    word,
                    font: fontNames[predictedClass],
                    confidence,
                });
            }
    
            return fontResults;
        }
    
        // OCR function
        function runOCR(image) {
            return Tesseract.recognize(
                image,
                'khm+eng',
                { logger: (m) => console.log(m) }
            ).then(({ data: { text } }) => text);
        }
    
        // Process PDF (no changes needed here)
        async function processPDF(file) {
            const pdf = await pdfjsLib.getDocument(URL.createObjectURL(file)).promise;
            const textData = [];
            for (let pageNumber = 1; pageNumber <= pdf.numPages; pageNumber++) {
                const page = await pdf.getPage(pageNumber);
                const viewport = page.getViewport({ scale: 1 });
                const canvas = document.createElement('canvas');
                canvas.height = viewport.height;
                canvas.width = viewport.width;
                await page.render({ canvasContext: canvas.getContext('2d'), viewport }).promise;
                const image = canvas.toDataURL();
                const img = new Image();
                img.src = image;
                textData.push(await runOCR(img));
            }
            return { text: textData.join('\n') };
        }
    
        // DOCX file generator
        function generateDocx(text, font, confidence) {
            const zip = new JSZip();
    
            // Escape any special HTML characters
            const escapedText = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    
            // Create Word document content (XML format)
            const docContent = `
            <w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
                <w:body>
                    <w:p><w:r><w:t>Detected Font: ${font}</w:t></w:r></w:p>
                    <w:p><w:r><w:t>Confidence: ${confidence}</w:t></w:r></w:p>
                    <w:p><w:r><w:t>${escapedText}</w:t></w:r></w:p>
                </w:body>
            </w:document>`;
    
            // Add content to the zip file (the document.xml part)
            zip.file('word/document.xml', docContent);
    
            // Add additional required files for the DOCX format
            zip.file('[Content_Types].xml', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
            <Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
                <Default Extension="xml" ContentType="application/xml"/>
                <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
                <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
            </Types>`);
    
            // Add relationships file (rels)
            zip.file('word/_rels/document.xml.rels', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
            <Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
                <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="document.xml"/>
            </Relationships>`);
    
            // Generate the DOCX file as a blob
            zip.generateAsync({ type: 'blob' }).then(content => {
                saveAs(content, 'ocr_result.docx');
            });
        }
    </script>

</body>
</html>
